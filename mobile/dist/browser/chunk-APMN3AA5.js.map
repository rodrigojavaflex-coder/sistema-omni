{"version":3,"sources":["node_modules/@capacitor/preferences/dist/esm/index.js","node_modules/capacitor-secure-storage-plugin/dist/esm/index.js","node_modules/capacitor-native-biometric/dist/esm/definitions.js","node_modules/capacitor-native-biometric/dist/esm/index.js","src/app/services/auth.service.ts"],"sourcesContent":["import { registerPlugin } from '@capacitor/core';\nconst Preferences = registerPlugin('Preferences', {\n    web: () => import('./web').then(m => new m.PreferencesWeb()),\n});\nexport * from './definitions';\nexport { Preferences };\n","import { registerPlugin } from '@capacitor/core';\nconst SecureStoragePlugin = registerPlugin('SecureStoragePlugin', {\n    web: () => import('./web').then(m => new m.SecureStoragePluginWeb()),\n});\nexport * from './definitions';\nexport { SecureStoragePlugin };\n","export var BiometryType;\n(function (BiometryType) {\n    // Android, iOS\n    BiometryType[BiometryType[\"NONE\"] = 0] = \"NONE\";\n    // iOS\n    BiometryType[BiometryType[\"TOUCH_ID\"] = 1] = \"TOUCH_ID\";\n    // iOS\n    BiometryType[BiometryType[\"FACE_ID\"] = 2] = \"FACE_ID\";\n    // Android\n    BiometryType[BiometryType[\"FINGERPRINT\"] = 3] = \"FINGERPRINT\";\n    // Android\n    BiometryType[BiometryType[\"FACE_AUTHENTICATION\"] = 4] = \"FACE_AUTHENTICATION\";\n    // Android\n    BiometryType[BiometryType[\"IRIS_AUTHENTICATION\"] = 5] = \"IRIS_AUTHENTICATION\";\n    // Android\n    BiometryType[BiometryType[\"MULTIPLE\"] = 6] = \"MULTIPLE\";\n})(BiometryType || (BiometryType = {}));\n/**\n * Keep this in sync with BiometricAuthError in README.md\n * Update whenever `convertToPluginErrorCode` functions are modified\n */\nexport var BiometricAuthError;\n(function (BiometricAuthError) {\n    BiometricAuthError[BiometricAuthError[\"UNKNOWN_ERROR\"] = 0] = \"UNKNOWN_ERROR\";\n    BiometricAuthError[BiometricAuthError[\"BIOMETRICS_UNAVAILABLE\"] = 1] = \"BIOMETRICS_UNAVAILABLE\";\n    BiometricAuthError[BiometricAuthError[\"USER_LOCKOUT\"] = 2] = \"USER_LOCKOUT\";\n    BiometricAuthError[BiometricAuthError[\"BIOMETRICS_NOT_ENROLLED\"] = 3] = \"BIOMETRICS_NOT_ENROLLED\";\n    BiometricAuthError[BiometricAuthError[\"USER_TEMPORARY_LOCKOUT\"] = 4] = \"USER_TEMPORARY_LOCKOUT\";\n    BiometricAuthError[BiometricAuthError[\"AUTHENTICATION_FAILED\"] = 10] = \"AUTHENTICATION_FAILED\";\n    BiometricAuthError[BiometricAuthError[\"APP_CANCEL\"] = 11] = \"APP_CANCEL\";\n    BiometricAuthError[BiometricAuthError[\"INVALID_CONTEXT\"] = 12] = \"INVALID_CONTEXT\";\n    BiometricAuthError[BiometricAuthError[\"NOT_INTERACTIVE\"] = 13] = \"NOT_INTERACTIVE\";\n    BiometricAuthError[BiometricAuthError[\"PASSCODE_NOT_SET\"] = 14] = \"PASSCODE_NOT_SET\";\n    BiometricAuthError[BiometricAuthError[\"SYSTEM_CANCEL\"] = 15] = \"SYSTEM_CANCEL\";\n    BiometricAuthError[BiometricAuthError[\"USER_CANCEL\"] = 16] = \"USER_CANCEL\";\n    BiometricAuthError[BiometricAuthError[\"USER_FALLBACK\"] = 17] = \"USER_FALLBACK\";\n})(BiometricAuthError || (BiometricAuthError = {}));\n","import { registerPlugin } from '@capacitor/core';\nconst NativeBiometric = registerPlugin('NativeBiometric', {\n    web: () => import('./web').then(m => new m.NativeBiometricWeb()),\n});\nexport * from './definitions';\nexport { NativeBiometric };\n","import { Injectable, inject } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Router } from '@angular/router';\nimport { Preferences } from '@capacitor/preferences';\nimport { Capacitor } from '@capacitor/core';\nimport { SecureStoragePlugin } from 'capacitor-secure-storage-plugin';\nimport { NativeBiometric } from 'capacitor-native-biometric';\nimport { BehaviorSubject, Observable, firstValueFrom } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport { Usuario, AuthResponse } from '../models/usuario.model';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  private http = inject(HttpClient);\n  private router = inject(Router);\n  private apiBaseUrl = this.resolveApiBaseUrl();\n  private apiUrl = `${this.apiBaseUrl}/auth`;\n\n  private readonly ACCESS_TOKEN_KEY = 'access_token';\n  private readonly REFRESH_TOKEN_KEY = 'refresh_token';\n  private readonly USER_KEY = 'current_user';\n  private readonly BIOMETRIC_ENABLED_KEY = 'biometric_enabled';\n  private readonly BIOMETRIC_CREDENTIALS_KEY = 'biometric_credentials';\n\n  private biometricSessionVerified = false;\n  private apiBaseUrlLogged = false;\n\n  private currentUserSubject = new BehaviorSubject<Usuario | null>(null);\n  public currentUser$ = this.currentUserSubject.asObservable();\n\n  private isAuthenticatedSubject = new BehaviorSubject<boolean>(false);\n  public isAuthenticated$ = this.isAuthenticatedSubject.asObservable();\n\n  constructor() {\n    this.checkStoredAuth();\n  }\n\n  /**\n   * Realiza login do usuário\n   */\n  async login(email: string, password: string, options?: { navigate?: boolean }): Promise<void> {\n    await this.performLogin(email, password, options);\n  }\n\n  private async performLogin(\n    email: string,\n    password: string,\n    options?: { navigate?: boolean }\n  ): Promise<void> {\n    try {\n      const response = await firstValueFrom(\n        this.http.post<AuthResponse>(`${this.apiUrl}/login`, { email, password })\n      );\n\n      const accessToken = response.accessToken ?? response.access_token;\n      const refreshToken = response.refreshToken ?? response.refresh_token;\n      if (!accessToken || !refreshToken) {\n        throw new Error('Tokens de autenticação não recebidos');\n      }\n      await this.setTokens(accessToken, refreshToken);\n      await this.setUser(response.user);\n      \n      this.currentUserSubject.next(response.user);\n      this.isAuthenticatedSubject.next(true);\n      this.biometricSessionVerified = true;\n      \n      if (options?.navigate !== false) {\n        this.router.navigate(['/home']);\n      }\n    } catch (error: any) {\n      const status = error?.status ? ` (HTTP ${error.status})` : '';\n      const serverMessage = error?.error?.message || error?.message;\n      const details = serverMessage ? `: ${serverMessage}` : '';\n      throw new Error(`Erro ao fazer login${status}${details}`);\n    }\n  }\n\n  /**\n   * Realiza logout\n   */\n  async logout(): Promise<void> {\n    try {\n      const refreshToken = await this.getRefreshToken();\n      if (refreshToken) {\n        await firstValueFrom(\n          this.http.post(`${this.apiUrl}/logout`, { refreshToken })\n        ).catch(() => {\n          // Ignora erro se o token já foi invalidado\n        });\n      }\n    } catch (error) {\n      // Ignora erros no logout\n    } finally {\n      await this.clearAuth();\n      this.currentUserSubject.next(null);\n      this.isAuthenticatedSubject.next(false);\n      this.biometricSessionVerified = false;\n      this.router.navigate(['/login']);\n    }\n  }\n\n  /**\n   * Bloqueia sessão local sem invalidar token no servidor\n   */\n  async lockSession(): Promise<void> {\n    await this.clearAuth();\n    this.currentUserSubject.next(null);\n    this.isAuthenticatedSubject.next(false);\n    this.biometricSessionVerified = false;\n  }\n\n  /**\n   * Verifica se o usuário está autenticado\n   */\n  isAuthenticated(): boolean {\n    return this.isAuthenticatedSubject.value;\n  }\n\n  /**\n   * Obtém o usuário atual\n   */\n  getCurrentUser(): Usuario | null {\n    return this.currentUserSubject.value;\n  }\n\n  /**\n   * Verifica se o usuário tem uma permissão específica\n   */\n  hasPermission(permission: string): boolean {\n    const permissoes = this.getUserPermissions();\n    return permissoes.includes(permission);\n  }\n\n  /**\n   * Verifica se o usuário tem alguma das permissões fornecidas\n   */\n  hasAnyPermission(permissions: string[]): boolean {\n    if (permissions.length === 0) {\n      return true;\n    }\n    const permissoes = this.getUserPermissions();\n    return permissions.some((permission) => permissoes.includes(permission));\n  }\n\n  private getUserPermissions(): string[] {\n    const user = this.currentUserSubject.value;\n    if (!user) {\n      return [];\n    }\n    const raw = user.perfil?.permissoes;\n    if (!raw) {\n      return [];\n    }\n    if (Array.isArray(raw)) {\n      return raw;\n    }\n    return raw\n      .split(',')\n      .map((value) => value.trim())\n      .filter((value) => value.length > 0);\n  }\n\n  /**\n   * Obtém o access token\n   */\n  async getAccessToken(): Promise<string | null> {\n    return this.getSecureItem(this.ACCESS_TOKEN_KEY);\n  }\n\n  /**\n   * Obtém o refresh token\n   */\n  async getRefreshToken(): Promise<string | null> {\n    return this.getSecureItem(this.REFRESH_TOKEN_KEY);\n  }\n\n  /**\n   * Atualiza o access token\n   */\n  async refreshAccessToken(): Promise<string | null> {\n    try {\n      const refreshToken = await this.getRefreshToken();\n      if (!refreshToken) {\n        throw new Error('No refresh token');\n      }\n\n      const response = await firstValueFrom(\n        this.http.post<{ accessToken: string }>(`${this.apiUrl}/refresh`, { refreshToken })\n      );\n\n      await this.setSecureItem(this.ACCESS_TOKEN_KEY, response.accessToken);\n      return response.accessToken;\n    } catch (error) {\n      await this.logout();\n      return null;\n    }\n  }\n\n  /**\n   * Verifica autenticação armazenada\n   */\n  private async checkStoredAuth(): Promise<void> {\n    const accessToken = await this.getAccessToken();\n    const userStr = await Preferences.get({ key: this.USER_KEY });\n\n    if (accessToken && userStr.value) {\n      try {\n        const user = JSON.parse(userStr.value);\n        this.currentUserSubject.next(user);\n        this.isAuthenticatedSubject.next(true);\n      } catch (error) {\n        await this.clearAuth();\n      }\n    }\n  }\n\n  /**\n   * Armazena tokens\n   */\n  private async setTokens(accessToken: string, refreshToken: string): Promise<void> {\n    await this.setSecureItem(this.ACCESS_TOKEN_KEY, accessToken);\n    await this.setSecureItem(this.REFRESH_TOKEN_KEY, refreshToken);\n  }\n\n  /**\n   * Armazena usuário\n   */\n  private async setUser(user: Usuario): Promise<void> {\n    await Preferences.set({ key: this.USER_KEY, value: JSON.stringify(user) });\n  }\n\n  /**\n   * Limpa dados de autenticação\n   */\n  private async clearAuth(): Promise<void> {\n    await this.removeSecureItem(this.ACCESS_TOKEN_KEY);\n    await this.removeSecureItem(this.REFRESH_TOKEN_KEY);\n    await Preferences.remove({ key: this.USER_KEY });\n  }\n\n  /**\n   * Verifica se biometria está disponível no dispositivo\n   */\n  async isBiometricAvailable(): Promise<boolean> {\n    if (!this.isNativePlatform()) {\n      return false;\n    }\n    try {\n      const { isAvailable } = await NativeBiometric.isAvailable({ useFallback: true });\n      return isAvailable;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Verifica se login biométrico está habilitado\n   */\n  async isBiometricEnabled(): Promise<boolean> {\n    const { value } = await Preferences.get({ key: this.BIOMETRIC_ENABLED_KEY });\n    if (value !== 'true') {\n      return false;\n    }\n\n    const credentials = await this.getBiometricCredentials();\n    return Boolean(credentials);\n  }\n\n  /**\n   * Habilita login biométrico para o usuário atual\n   */\n  async enableBiometricLogin(email: string, password: string): Promise<boolean> {\n    if (!this.isNativePlatform()) {\n      return false;\n    }\n    const available = await this.isBiometricAvailable();\n    if (!available) {\n      return false;\n    }\n\n    try {\n      await NativeBiometric.verifyIdentity({\n        reason: 'Confirme sua identidade para ativar o login por digital',\n        title: 'Ativar login por digital',\n        subtitle: 'Use sua biometria para acessar mais rápido',\n        description: 'Sua biometria será usada para liberar o login rapidamente.',\n        negativeButtonText: 'Agora não',\n        useFallback: true,\n        maxAttempts: 3\n      });\n    } catch {\n      return false;\n    }\n\n    await this.setBiometricCredentials({ email, password });\n    await Preferences.set({ key: this.BIOMETRIC_ENABLED_KEY, value: 'true' });\n    return true;\n  }\n\n  /**\n   * Login usando biometria e refresh token armazenado\n   */\n  async loginWithBiometrics(): Promise<void> {\n    if (!this.isNativePlatform()) {\n      throw new Error('Biometria indisponível neste ambiente');\n    }\n    const enabled = await this.isBiometricEnabled();\n    if (!enabled) {\n      throw new Error('Login biométrico não está habilitado');\n    }\n\n    const unlocked = await this.requireBiometricUnlock();\n    if (!unlocked) {\n      throw new Error('Autenticação biométrica não confirmada');\n    }\n\n    const credentials = await this.getBiometricCredentials();\n    if (!credentials) {\n      throw new Error('Credenciais biométricas não encontradas');\n    }\n\n    await this.performLogin(credentials.email, credentials.password, { navigate: false });\n  }\n\n  async disableBiometricLogin(): Promise<void> {\n    await Preferences.remove({ key: this.BIOMETRIC_ENABLED_KEY });\n    await this.removeSecureItem(this.BIOMETRIC_CREDENTIALS_KEY);\n    this.biometricSessionVerified = false;\n  }\n\n  async requireBiometricUnlock(): Promise<boolean> {\n    if (this.biometricSessionVerified) {\n      return true;\n    }\n\n    if (!this.isNativePlatform()) {\n      return true;\n    }\n\n    const enabled = await this.isBiometricEnabled();\n    if (!enabled) {\n      return true;\n    }\n\n    try {\n      await NativeBiometric.verifyIdentity({\n        reason: 'Confirme sua identidade para entrar',\n        title: 'Login por digital',\n        subtitle: 'Use sua biometria para acessar',\n        description: 'Sua biometria será usada para validar o acesso.',\n        negativeButtonText: 'Cancelar',\n        useFallback: true,\n        maxAttempts: 3\n      });\n      this.biometricSessionVerified = true;\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  private async getBiometricCredentials(): Promise<{ email: string; password: string } | null> {\n    const value = await this.getSecureItem(this.BIOMETRIC_CREDENTIALS_KEY);\n    if (!value) {\n      return null;\n    }\n\n    try {\n      const parsed = JSON.parse(value);\n      if (!parsed?.email || !parsed?.password) {\n        return null;\n      }\n      return { email: parsed.email, password: parsed.password };\n    } catch {\n      return null;\n    }\n  }\n\n  private async setBiometricCredentials(credentials: { email: string; password: string }): Promise<void> {\n    await this.setSecureItem(this.BIOMETRIC_CREDENTIALS_KEY, JSON.stringify(credentials));\n  }\n\n  private async getSecureItem(key: string): Promise<string | null> {\n    try {\n      const { value } = await SecureStoragePlugin.get({ key });\n      return value ?? null;\n    } catch {\n      return null;\n    }\n  }\n\n  private async setSecureItem(key: string, value: string): Promise<void> {\n    await SecureStoragePlugin.set({ key, value });\n  }\n\n  private async removeSecureItem(key: string): Promise<void> {\n    try {\n      await SecureStoragePlugin.remove({ key });\n    } catch {\n      // Ignora remoção se não existir\n    }\n  }\n\n  private isNativePlatform(): boolean {\n    return Capacitor.getPlatform() !== 'web';\n  }\n\n  private resolveApiBaseUrl(): string {\n    const platform = Capacitor.getPlatform();\n    const baseUrl = this.isNativePlatform()\n      ? environment.apiUrlNative || environment.apiUrl\n      : environment.apiUrl;\n\n    if (!this.apiBaseUrlLogged) {\n      this.apiBaseUrlLogged = true;\n      console.info(`[OMNI] API Base URL: ${baseUrl} (platform: ${platform})`);\n    }\n\n    return baseUrl;\n  }\n}\n"],"mappings":"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","names":["BiometryType","BiometricAuthError","registerPlugin"],"x_google_ignoreList":[0,1,2,3]}